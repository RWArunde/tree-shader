This was a project for CS 419 at Oregon State University. The .glib file can be opened with GLman, a program designed for OpenGL shader development. GLman can be downloaded at http://web.engr.oregonstate.edu/~mjb/glman/

Project writeup:

The goal of this project was to create a mesh resembling a maple tree by tessellating a cylinder. The finished product was slightly more complicated, and used most of the rendering strategies we learned about this term. At a glance, two rendering passes are used. The first creates a polka dotted texture that determines where branches should be placed on the tree and how big they should be. The second pass wraps this texture on a cylinder, tessellates out branches where there’s a dot, adds extra quads for leaf textures, then lights and recolors the mesh with some actual tree textures.
The first pass consists of a vertex and fragment shader that are passed a single quad. The vertex shader sets the positions of the quad’s corners to the corners of the view volume, and then creates an array of 19 vec3s, which give xy position and size of dots. Originally I wanted to space these evenly and apply noise to distort them, like in the interactive polka dots project, but once it hit the tessellation stage this looked more like a spiked club than a tree, so I opted to just bash on my keyboard for pseudo-random placements of branches. The fragment shader grabs the uv position of each fragment and checks if the fragment should be in a dot, and colors accordingly.
The second pass has the whole shebang, a vertex, tessellation, geometry, and fragment shader. This time the vertex shader takes 64 vertices with unique ids, and arranges them into an 8x8 grid. The tessellation control shader simply applies the amount of detail given on the slider. Things start to get really freaky in the tessellation evaluation shader. Here, the grid is wrapped into a cylinder, and new uv coordinates are generated to wrap our polka dot texture. If a vertex falls into a dot, a few things happen. First, we calculate what direction the branch should be pointing by calculating the normal on the cylinder at the center of the dot. For visual interest, this vector gets rotated with some added noise. Then, we generate new uv coordinates in polar form from the center of the dot. Armed with these new coordinates, we move the vertex out to create a new cylinder that tapers and bends upwards like a tree branch, and calculate a new normal. Finally, we tag a few vertices on each branch to receive a leaf texture. For the most part, the geometry shader is pretty simple, taking three vertices and passing out a strip of a single triangle. However, if a vertex is tagged to receive a leaf, things get trickier. Using the vertex’s normal, we calculate a new normal for the quad we’re going to place, and distort it with noise. We then emit 4 vertices to place this quad above the branch, but since this creates a strip of triangles attached to the branch, we tag the first two of these vertices to be immediately discarded by the fragment shader. This way, we get the triangle in the branch and the quad for the leaf, with none of the triangles in between. The fragment shader wraps everything up by applying per pixel lighting, and drawing on the trunk and leaf textures.